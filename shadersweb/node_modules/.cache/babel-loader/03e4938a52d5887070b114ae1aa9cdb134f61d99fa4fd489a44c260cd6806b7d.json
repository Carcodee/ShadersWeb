{"ast":null,"code":"export async function CreateWebGPUCanvas(width, height) {\n  let canvas = document.createElement(\"canvas\");\n  canvas.width = width;\n  canvas.height = height;\n  if (!navigator.gpu) {\n    throw new Error(\"WebGPU not supported on this browser.\");\n  }\n  const adapter = await navigator.gpu.requestAdapter();\n  if (!adapter) {\n    throw new Error(\"No appropiate gpu adapter found.\");\n  }\n  const device = await adapter.requestDevice();\n  if (!device) {\n    throw new Error(\"No appropiate device.\");\n  }\n  const context = canvas.getContext(\"webgpu\");\n  const canvasFormat = navigator.gpu.getPreferredCanvasFormat();\n  context.configure({\n    device: device,\n    format: canvasFormat\n  });\n  const vertices = new Float32Array([\n  //   X,    Y,\n  -0.8, -0.8,\n  // Triangle 1 (Blue)\n  0.8, -0.8, 0.8, 0.8, -0.8, -0.8,\n  // Triangle 2 (Red)\n  0.8, 0.8, -0.8, 0.8]);\n  const vertexBuffer = device.createBuffer({\n    label: \"Cell vertices\",\n    size: vertices.byteLength,\n    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST\n  });\n  device.queue.writeBuffer(vertexBuffer, 0, vertices);\n  const vertexBufferLayout = {\n    arrayStride: 8,\n    attributes: [{\n      format: \"float32x2\",\n      offset: 0,\n      shaderLocation: 0\n    }]\n  };\n  const ShaderModule = device.createShaderModule({\n    label: \"Base Shader\",\n    code: `\n\n                  struct VertexOut{\n                      @builtin(position) position: vec4f,\n                      @location(0) col: vec4f,\n                  };\n\n                  @vertex\n                      fn vertexMain(@location(0) pos: vec2f) ->\n                      VertexOut {\n                      var vertexOut: VertexOut;\n                      vertexOut.position = vec4f(pos, 0, 1);\n                      vertexOut.col = vec4f(pos, 1, 1);\n                      return vertexOut;\n\n                  }\n\n                  @fragment\n                      fn fragmentMain(inData: VertexOut) -> @location(0) vec4f {\n                      return vec4f(inData.col);\n                  }\n          `\n  });\n  const Pipeline = device.createRenderPipeline({\n    label: \"Graphics Pipeline\",\n    layout: \"auto\",\n    vertex: {\n      module: ShaderModule,\n      entryPoint: \"vertexMain\",\n      buffers: [vertexBufferLayout]\n    },\n    fragment: {\n      module: ShaderModule,\n      entryPoint: \"fragmentMain\",\n      targets: [{\n        format: canvasFormat\n      }]\n    }\n  });\n  const encoder = device.createCommandEncoder();\n  const renderPass = encoder.beginRenderPass({\n    colorAttachments: [{\n      view: context.getCurrentTexture().createView(),\n      loadOp: \"clear\",\n      storeOp: \"store\",\n      clearValue: {\n        r: 0,\n        g: 0,\n        b: 0.4,\n        a: 1\n      }\n    }]\n  });\n  renderPass.setPipeline(Pipeline);\n  renderPass.setVertexBuffer(0, vertexBuffer);\n  renderPass.draw(vertices.length / 2);\n  renderPass.end();\n  const commandBuffer = encoder.finish();\n  device.queue.submit([commandBuffer]);\n  return canvas;\n}\n_c = CreateWebGPUCanvas;\nvar _c;\n$RefreshReg$(_c, \"CreateWebGPUCanvas\");","map":{"version":3,"names":["CreateWebGPUCanvas","width","height","canvas","document","createElement","navigator","gpu","Error","adapter","requestAdapter","device","requestDevice","context","getContext","canvasFormat","getPreferredCanvasFormat","configure","format","vertices","Float32Array","vertexBuffer","createBuffer","label","size","byteLength","usage","GPUBufferUsage","VERTEX","COPY_DST","queue","writeBuffer","vertexBufferLayout","arrayStride","attributes","offset","shaderLocation","ShaderModule","createShaderModule","code","Pipeline","createRenderPipeline","layout","vertex","module","entryPoint","buffers","fragment","targets","encoder","createCommandEncoder","renderPass","beginRenderPass","colorAttachments","view","getCurrentTexture","createView","loadOp","storeOp","clearValue","r","g","b","a","setPipeline","setVertexBuffer","draw","length","end","commandBuffer","finish","submit","_c","$RefreshReg$"],"sources":["/Users/kevinkhuu/Documents/GitHub/ShadersWeb/shadersweb/src/Engine/Core.js"],"sourcesContent":["\nexport async function CreateWebGPUCanvas (width, height){\n\n    let canvas = document.createElement(\"canvas\");\n    canvas.width = width;\n    canvas.height = height;\n    if (!navigator.gpu) {\n        throw new Error(\"WebGPU not supported on this browser.\");\n    }\n    const adapter = await navigator.gpu.requestAdapter();\n    if(!adapter){\n        throw new Error(\"No appropiate gpu adapter found.\");\n    }\n    const device = await adapter.requestDevice();\n    if (!device) {\n        throw new Error(\"No appropiate device.\");\n    }\n    const context = canvas.getContext(\"webgpu\");\n    const canvasFormat = navigator.gpu.getPreferredCanvasFormat();\n    context.configure(\n        {\n            device: device,\n            format: canvasFormat,\n        }\n    )\n\n    const vertices = new Float32Array([\n        //   X,    Y,\n        -0.8, -0.8, // Triangle 1 (Blue)\n        0.8, -0.8,\n        0.8,  0.8,\n\n        -0.8, -0.8, // Triangle 2 (Red)\n        0.8,  0.8,\n        -0.8,  0.8,\n    ]);\n\n    const vertexBuffer = device.createBuffer({\n        label: \"Cell vertices\",\n        size: vertices.byteLength,\n        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\n    });\n\n    device.queue.writeBuffer(vertexBuffer, 0, vertices);\n\n    const vertexBufferLayout = {\n        arrayStride: 8,\n        attributes: [{\n            format: \"float32x2\",\n            offset: 0,\n            shaderLocation: 0,\n        }]\n    };\n\n    const ShaderModule = device.createShaderModule({\n        label: \"Base Shader\",\n        code: `\n\n                  struct VertexOut{\n                      @builtin(position) position: vec4f,\n                      @location(0) col: vec4f,\n                  };\n\n                  @vertex\n                      fn vertexMain(@location(0) pos: vec2f) ->\n                      VertexOut {\n                      var vertexOut: VertexOut;\n                      vertexOut.position = vec4f(pos, 0, 1);\n                      vertexOut.col = vec4f(pos, 1, 1);\n                      return vertexOut;\n\n                  }\n\n                  @fragment\n                      fn fragmentMain(inData: VertexOut) -> @location(0) vec4f {\n                      return vec4f(inData.col);\n                  }\n          `\n\n    });\n\n    const Pipeline = device.createRenderPipeline({\n        label: \"Graphics Pipeline\",\n        layout: \"auto\",\n        vertex: {\n            module: ShaderModule,\n            entryPoint: \"vertexMain\",\n            buffers: [vertexBufferLayout]\n        },\n        fragment: {\n            module: ShaderModule,\n            entryPoint: \"fragmentMain\",\n            targets: [{\n                format: canvasFormat\n            }],\n        }\n    })\n    const encoder = device.createCommandEncoder();\n    const renderPass = encoder.beginRenderPass(\n        {\n            colorAttachments: [{\n                view: context.getCurrentTexture().createView(),\n                loadOp: \"clear\",\n                storeOp: \"store\",\n                clearValue: {r: 0, g: 0, b: 0.4, a:1},\n            }],\n        }\n    )\n\n    renderPass.setPipeline(Pipeline);\n    renderPass.setVertexBuffer(0, vertexBuffer);\n    renderPass.draw(vertices.length/2);\n\n    renderPass.end();\n    const commandBuffer = encoder.finish();\n    device.queue.submit([commandBuffer]);\n\n    return canvas;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}