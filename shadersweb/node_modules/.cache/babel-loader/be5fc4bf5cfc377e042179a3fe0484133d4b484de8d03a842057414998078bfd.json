{"ast":null,"code":"export async function CreateWebGPUCanvas(width, height) {\n  let canvas = document.createElement(\"canvas\");\n  canvas.width = width;\n  canvas.height = height;\n  if (!navigator.gpu) {\n    throw new Error(\"WebGPU not supported on this browser.\");\n  }\n  const adapter = await navigator.gpu.requestAdapter();\n  if (!adapter) {\n    throw new Error(\"No appropiate gpu adapter found.\");\n  }\n  const device = await adapter.requestDevice();\n  if (!device) {\n    throw new Error(\"No appropiate device.\");\n  }\n  const context = canvas.getContext(\"webgpu\");\n  const canvasFormat = navigator.gpu.getPreferredCanvasFormat();\n  context.configure({\n    device: device,\n    format: canvasFormat\n  });\n  const vertices = new Float32Array([\n  //   X,    Y,\n  -0.8, -0.8,\n  // Triangle 1 (Blue)\n  0.8, -0.8, 0.8, 0.8, -0.8, -0.8,\n  // Triangle 2 (Red)\n  0.8, 0.8, -0.8, 0.8]);\n  const vertexBuffer = device.createBuffer({\n    label: \"Cell vertices\",\n    size: vertices.byteLength,\n    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST\n  });\n  device.queue.writeBuffer(vertexBuffer, 0, vertices);\n  const vertexBufferLayout = {\n    arrayStride: 8,\n    attributes: [{\n      format: \"float32x2\",\n      offset: 0,\n      shaderLocation: 0\n    }]\n  };\n  const ShaderModule = device.createShaderModule({\n    label: \"Base Shader\",\n    code: `\n\n                  struct VertexOut{\n                      @builtin(position) position: vec4f,\n                      @location(0) col: vec4f,\n                  };\n\n                  @vertex\n                      fn vertexMain(@location(0) pos: vec2f) ->\n                      VertexOut {\n                      var vertexOut: VertexOut;\n                      vertexOut.position = vec4f(pos, 0, 1);\n                      vertexOut.col = vec4f(0.5, 0.5, 1, 1);\n                      return vertexOut;\n\n                  }\n\n                  @fragment\n                      fn fragmentMain(inData: VertexOut) -> @location(0) vec4f {\n                      return vec4f(inData.col);\n                  }\n          `\n  });\n  const Pipeline = device.createRenderPipeline({\n    label: \"Graphics Pipeline\",\n    layout: \"auto\",\n    vertex: {\n      module: ShaderModule,\n      entryPoint: \"vertexMain\",\n      buffers: [vertexBufferLayout]\n    },\n    fragment: {\n      module: ShaderModule,\n      entryPoint: \"fragmentMain\",\n      targets: [{\n        format: canvasFormat\n      }]\n    }\n  });\n  const encoder = device.createCommandEncoder();\n  const renderPass = encoder.beginRenderPass({\n    colorAttachments: [{\n      view: context.getCurrentTexture().createView(),\n      loadOp: \"clear\",\n      storeOp: \"store\",\n      clearValue: {\n        r: 0,\n        g: 0,\n        b: 0.4,\n        a: 1\n      }\n    }]\n  });\n  renderPass.setPipeline(Pipeline);\n  renderPass.setVertexBuffer(0, vertexBuffer);\n  renderPass.draw(vertices.length / 2);\n  renderPass.end();\n  const commandBuffer = encoder.finish();\n  device.queue.submit([commandBuffer]);\n  return canvas;\n}\n_c = CreateWebGPUCanvas;\nvar _c;\n$RefreshReg$(_c, \"CreateWebGPUCanvas\");","map":{"version":3,"names":["CreateWebGPUCanvas","width","height","canvas","document","createElement","navigator","gpu","Error","adapter","requestAdapter","device","requestDevice","context","getContext","canvasFormat","getPreferredCanvasFormat","configure","format","vertices","Float32Array","vertexBuffer","createBuffer","label","size","byteLength","usage","GPUBufferUsage","VERTEX","COPY_DST","queue","writeBuffer","vertexBufferLayout","arrayStride","attributes","offset","shaderLocation","ShaderModule","createShaderModule","code","Pipeline","createRenderPipeline","layout","vertex","module","entryPoint","buffers","fragment","targets","encoder","createCommandEncoder","renderPass","beginRenderPass","colorAttachments","view","getCurrentTexture","createView","loadOp","storeOp","clearValue","r","g","b","a","setPipeline","setVertexBuffer","draw","length","end","commandBuffer","finish","submit","_c","$RefreshReg$"],"sources":["/Users/kevinkhuu/Documents/GitHub/ShadersWeb/shadersweb/src/Engine/Core.js"],"sourcesContent":["export async function CreateWebGPUCanvas(width, height) {\n\tlet canvas = document.createElement(\"canvas\");\n\tcanvas.width = width;\n\tcanvas.height = height;\n\tif (!navigator.gpu) {\n\t\tthrow new Error(\"WebGPU not supported on this browser.\");\n\t}\n\tconst adapter = await navigator.gpu.requestAdapter();\n\tif (!adapter) {\n\t\tthrow new Error(\"No appropiate gpu adapter found.\");\n\t}\n\tconst device = await adapter.requestDevice();\n\tif (!device) {\n\t\tthrow new Error(\"No appropiate device.\");\n\t}\n\tconst context = canvas.getContext(\"webgpu\");\n\tconst canvasFormat = navigator.gpu.getPreferredCanvasFormat();\n\tcontext.configure({\n\t\tdevice: device,\n\t\tformat: canvasFormat,\n\t});\n\n\tconst vertices = new Float32Array([\n\t\t//   X,    Y,\n\t\t-0.8,\n\t\t-0.8, // Triangle 1 (Blue)\n\t\t0.8,\n\t\t-0.8,\n\t\t0.8,\n\t\t0.8,\n\n\t\t-0.8,\n\t\t-0.8, // Triangle 2 (Red)\n\t\t0.8,\n\t\t0.8,\n\t\t-0.8,\n\t\t0.8,\n\t]);\n\n\tconst vertexBuffer = device.createBuffer({\n\t\tlabel: \"Cell vertices\",\n\t\tsize: vertices.byteLength,\n\t\tusage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\n\t});\n\n\tdevice.queue.writeBuffer(vertexBuffer, 0, vertices);\n\n\tconst vertexBufferLayout = {\n\t\tarrayStride: 8,\n\t\tattributes: [\n\t\t\t{\n\t\t\t\tformat: \"float32x2\",\n\t\t\t\toffset: 0,\n\t\t\t\tshaderLocation: 0,\n\t\t\t},\n\t\t],\n\t};\n\n\tconst ShaderModule = device.createShaderModule({\n\t\tlabel: \"Base Shader\",\n\t\tcode: `\n\n                  struct VertexOut{\n                      @builtin(position) position: vec4f,\n                      @location(0) col: vec4f,\n                  };\n\n                  @vertex\n                      fn vertexMain(@location(0) pos: vec2f) ->\n                      VertexOut {\n                      var vertexOut: VertexOut;\n                      vertexOut.position = vec4f(pos, 0, 1);\n                      vertexOut.col = vec4f(0.5, 0.5, 1, 1);\n                      return vertexOut;\n\n                  }\n\n                  @fragment\n                      fn fragmentMain(inData: VertexOut) -> @location(0) vec4f {\n                      return vec4f(inData.col);\n                  }\n          `,\n\t});\n\n\tconst Pipeline = device.createRenderPipeline({\n\t\tlabel: \"Graphics Pipeline\",\n\t\tlayout: \"auto\",\n\t\tvertex: {\n\t\t\tmodule: ShaderModule,\n\t\t\tentryPoint: \"vertexMain\",\n\t\t\tbuffers: [vertexBufferLayout],\n\t\t},\n\t\tfragment: {\n\t\t\tmodule: ShaderModule,\n\t\t\tentryPoint: \"fragmentMain\",\n\t\t\ttargets: [\n\t\t\t\t{\n\t\t\t\t\tformat: canvasFormat,\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t});\n\tconst encoder = device.createCommandEncoder();\n\tconst renderPass = encoder.beginRenderPass({\n\t\tcolorAttachments: [\n\t\t\t{\n\t\t\t\tview: context.getCurrentTexture().createView(),\n\t\t\t\tloadOp: \"clear\",\n\t\t\t\tstoreOp: \"store\",\n\t\t\t\tclearValue: { r: 0, g: 0, b: 0.4, a: 1 },\n\t\t\t},\n\t\t],\n\t});\n\n\trenderPass.setPipeline(Pipeline);\n\trenderPass.setVertexBuffer(0, vertexBuffer);\n\trenderPass.draw(vertices.length / 2);\n\n\trenderPass.end();\n\tconst commandBuffer = encoder.finish();\n\tdevice.queue.submit([commandBuffer]);\n\n\treturn canvas;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}